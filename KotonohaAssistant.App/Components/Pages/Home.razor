@page "/"
@rendermode InteractiveServer
@implements IDisposable
@using System.Text.RegularExpressions
@using KotonohaAssistant.AI.Functions
@using KotonohaAssistant.AI.Services
@using KotonohaAssistant.Core
@using KotonohaAssistant.Core.Utils
@using Toolbelt.Blazor.SpeechRecognition
@inject SpeechRecognition SpeechRecognition

<PageTitle>Kotonoha Assistant</PageTitle>

<h1>Kotonoha Assistant</h1>
<div style="display: flex; gap: 30px">
    <div style="width: 30%">
        <h2>ステータス</h2>
        <div>
            <p>Is your turn: <b>@(_isYourTurn ? "YES" : "NO")</b></p>
            <p>Is in conversation: <b>@(_isInConversation ? "YES" : "NO")</b></p>
        </div>
        <h2>ウェイクワード</h2>
        <div>
            <p>「ねえ、あかねちゃん」</p>
            <p>「ねえ、あおいちゃん」</p>
            <p>「あかねちゃん、いる？」</p>
            <p>「あおいちゃん、いる？」</p>
        </div>
    </div>
    <div style="width: 50%">
        <h2>会話履歴</h2>
        @foreach (var message in _messages)
        {
            if (message.Function is not null)
            {
                var arguments = string.Join(", ", message.Function.Arguments.Select(a => $"{a.Key}={a.Value}") ?? []);

                <div style="background: #f5f5f5; color: #adadad; padding: 5px 20px 5px; margin: 5px 0px">
                    <details>
                        <summary>
                            @(message.Function.Name)(@(arguments))
                        </summary>
                        <p style="white-space: pre-line">
                            @(message.Function.Result)
                        </p>
                    </details>
                </div>
            }
            else
            {
                var color = message.Talking switch
                {
                    Kotonoha.Akane => "pink",
                    Kotonoha.Aoi => "lightblue",
                    _ => "lightgray"
                };
                var justifyContent = message.Talking is null ? "flex-end" : "flex-start";

                <div style="display: flex; justify-content: @justifyContent;">
                    <div style="margin: 7px 0px; padding: 0px 20px; border-radius: 10px; background-color: @color;">
                        <p>@(message.Text)</p>
                    </div>
                </div>
            }
        }

        @if (_isYourTurn)
        {
            <div style="display: flex; justify-content: flex-end;">
                <div style="margin: 7px 0px; padding: 0px 20px; border-radius: 10px; background-color: lightgray;">
                    <p>
                        &gt;&nbsp;@(_talkingText)
                        @if (_isInConversation)
                        {
                            <span class="blinking-underscore">_</span>
                        }
                    </p>
                </div>
            </div>
        }
    </div>
</div>

@code {
    class ChatMessageInfo
    {
        public string? Text { get; set; }
        public Kotonoha? Talking { get; set; }
        public ConversationFunction? Function { get; set; }
    }

    /// <summary>
    /// 自分の番かどうか
    /// </summary>
    private bool _isYourTurn = true;

    /// <summary>
    /// 会話中かどうか
    /// </summary>
    private bool _isInConversation = false;

    /// <summary>
    /// 入力中のメッセージ
    /// </summary>
    private string _talkingText = "";

    /// <summary>
    /// 会話履歴
    /// </summary>
    private readonly List<ChatMessageInfo> _messages = new();

    /// <summary>
    /// 会話終了タイムアウト用
    /// </summary>
    private CancellationTokenSource? _conversationTimer;

    private ConversationService? _conversationService = null;
    private VoiceClient? _voiceClient = null;

    protected override void OnInitialized()
    {
        this.SpeechRecognition.Lang = "ja-JP";
        this.SpeechRecognition.InterimResults = true;
        this.SpeechRecognition.Continuous = true;
        this.SpeechRecognition.Result += OnSpeechRecognized;
        _ = this.SpeechRecognition.StartAsync();

        var apiKey = Environment.GetEnvironmentVariable("OPENAI_API_KEY") ?? "";
        _conversationService = new ConversationService(
            apiKey,
            Settings.ModelName,
            Settings.Functions,
            Settings.ExcludeFunctionNamesFromLazyMode,
            defaultSister: Kotonoha.Akane,
            Settings.AkaneBehaviour,
            Settings.AoiBehaviour);
        _voiceClient = new VoiceClient();
    }

    private static bool ContainsWakeWord(string? text)
    {
        if (string.IsNullOrWhiteSpace(text))
        {
            return false;
        }

        var removed = Regex.Replace(text, @"[、。？?\s]", string.Empty);
        return Settings.WakeWords.Any(word => removed.Contains(word));
    }

    private void OnSpeechRecognized(object? sender, SpeechRecognitionEventArgs args)
    {
        // 琴葉姉妹の会話中は受け付けない
        if (!_isYourTurn)
        {
            return;
        }

        var lastResult = args?.Results?.LastOrDefault();
        if (lastResult is null)
        {
            return;
        }

        // 一言でも喋ると会話終了タイムアウトをリセットする
        ResetConversationTimeout();

        var transcript = lastResult.Items?[0].Transcript;
        if (transcript is null)
        {
            return;
        }

        transcript = ReplaceFuzzyMatchWord(transcript);

        _talkingText = transcript;
        this.StateHasChanged();

        // こちらの入力がまだ終わっていない場合
        if (!lastResult.IsFinal)
        {
            return;
        }

        // ウェイクワードが含まれていたら会話開始

        if (ContainsWakeWord(transcript))
        {
            _isInConversation = true;
        }

        // 会話中の入力はすべて送信する
        if (_isInConversation)
        {
            _messages.Add(new ChatMessageInfo { Text = transcript });

            _ = SendMessage(transcript);
        }

        string ReplaceFuzzyMatchWord(string input)
        {
            input = Regex.Replace(input, Settings.FuzzyMatchAkane.From, Settings.FuzzyMatchAkane.To);
            input = Regex.Replace(input, Settings.FuzzyMatchAoi.From, Settings.FuzzyMatchAoi.To);
            return input;
        }
    }

    /// <summary>
    /// メッセージの生成＆読み上げ
    /// </summary>
    /// <param name="message"></param>
    /// <returns></returns>
    private async Task SendMessage(string message)
    {
        if (_conversationService is null || _voiceClient is null)
        {
            return;
        }

        _isYourTurn = false;
        this.StateHasChanged();

        await this.SpeechRecognition.StopAsync();

        await foreach (var result in _conversationService.TalkingWithKotonohaSisters(message))
        {
            // 関数呼び出しがあった場合は個別に表示
            if (result.Functions is not null and not [])
            {
                _messages.AddRange(result.Functions.Select(f => new ChatMessageInfo { Function = f }));
            }

            _messages.Add(new ChatMessageInfo
                {
                    Text = result.Message,
                    Talking = result.Sister,
                });

            this.StateHasChanged();

            // 読み上げ
            await _voiceClient.SpeakAsync(result.Sister, result.Message);
        }

        await this.SpeechRecognition.StartAsync();

        _isYourTurn = true;
        _talkingText = "";
        this.StateHasChanged();

        // 5秒間入力を受け付ける
        StartConversationTimeout(Settings.CoversationTimeout);
    }

    /// <summary>
    /// 指定した時間経過すると会話を終了する
    /// </summary>
    private void StartConversationTimeout(int interval)
    {
        _conversationTimer?.Cancel(); // 前のタイマーをキャンセル
        _conversationTimer = new CancellationTokenSource();
        var token = _conversationTimer.Token;

        // 5秒後に会話を終了
        Task.Delay(interval, token).ContinueWith(t =>
        {
            if (!token.IsCancellationRequested)
            {
                _isInConversation = false; // 指定時間経過後に会話終了
                StateHasChanged();
            }
        }, TaskScheduler.FromCurrentSynchronizationContext());
    }

    /// <summary>
    /// 会話終了のタイムアウトをリセットする
    /// </summary>
    private void ResetConversationTimeout()
    {
        _conversationTimer?.Cancel(); // 前のタイマーをキャンセル
        _conversationTimer = new CancellationTokenSource();
    }

    public void Dispose()
    {
        this.SpeechRecognition.Result -= OnSpeechRecognized;
        _voiceClient?.Dispose();
        _conversationTimer?.Cancel();
    }
}
